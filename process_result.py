"""
process the results generated by standford NLP
"""

import os
import json
import sys
import re
import argparse
import codecs
#reload(sys)
#sys.setdefaultencoding('UTF8')


def get_json(source):
    data = {}
    tag = ""
    with open(source,"r") as f:
        for line in f:
            line = line.rstrip()
            m = re.search("^(\w+):$",line)
            if m is not None:
                tag = m.group(1)
                data[tag] = {}
            else:
                m = re.search("^\t(.+?):(\d+)$",line)
                if m is not None:
                    data[tag][m.group(1)] = int(m.group(2))
                else:
                    print "line did not match:"
                    print line
    with open(source+".json","w") as f:
        f.write(json.dumps(data))
    return data


def output_top(data,dest,top):
    all_phrases = {}
    f = codecs.open(dest,"w","utf-8")
    for tag in data:
        sorted_sub = sorted(data[tag].items(),key = lambda x:x[1], reverse=True)
        f.write("%s:\n" %tag)
        i = 0
        for (k,v) in sorted_sub:
            k = unicode(k, "utf-8")
            f.write("\t"+k+":"+str(v)+"\n")
            i+=1
            if i>= top:
                break
        for p in data[tag]:
            if p not in all_phrases:
                all_phrases[p] = 0
            all_phrases[p] += 1
    sorted_all = sorted(all_phrases.items(),key = lambda x:x[1], reverse=True)
    f.write("ALL:\n")
    i=0
    for (k,v) in sorted_all:
        k = unicode(k, "utf-8")
        f.write("\t"+k+":"+str(v)+"\n")
        i+=1
        if i>= top:
            break
    f.close()



def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("source")
    parser.add_argument("dest")
    parser.add_argument("--top",'-t',type=int,default=10)

    args=parser.parse_args()
    data = get_json(args.source)
    output_top(data,args.dest,args.top)

if __name__=="__main__":
    main()

